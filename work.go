package rabbitmq

import (
	"context"

	"github.com/rabbitmq/amqp091-go"
	"golang.org/x/sync/errgroup"
)

// Worker описывает функцию для работы с соединением RabbitMQ.
type Worker = func(*amqp091.Channel) error

// Work осуществляет подключение к серверу RabbitMQ и инициализирует обработчики сервисов с этим соединением.
// В случае сбоя пытается восстановить соединение и заново инициализировать обработчики.
//
// Для каждого обработчика инициализируется отдельный канал в рамках общего соединения с RabbitMQ. При завершении
// обработчика с ошибкой соединение переустанавливается и происходит установка нового соединения и повторная
// инициализация всех обработчиков.
//
// Плановое завершение работы сервисов осуществляется через контекст.
func Work(ctx context.Context, addr string, workers ...Worker) error {
	for {
		conn, err := Connect(addr) // подключаемся к серверу
		if err != nil {
			return err // ошибка установки соединения
		}

		// инициализируем группу обработчиков соединения
		group, groupCtx := errgroup.WithContext(ctx)
		// добавляем обработчик, который отслеживает ошибки соединения
		group.Go(func() error {
			select {
			case err = <-conn.NotifyClose(make(chan *amqp091.Error)):
				return err // при плановом закрытии ошибка будет пустая
			case <-groupCtx.Done(): // плановое завершение
				return nil
			}
		})

		// запускаем зарегистрированные для данного соединения обработчики
		for _, worker := range workers {
			if groupCtx.Err() != nil {
				break // прерываем инициализацию при ошибке в одном из сервисов, соединении или глобальной остановке
			}

			worker := worker // копируем в текущий стек
			group.Go(func() error {
				ch, err := conn.Channel() // для каждого сервиса создаём отдельный канал
				if err != nil {
					return err
				}
				defer ch.Close()  // закрываем канал по завершению
				return worker(ch) // запускаем обработчик сервиса на заданном канале
			})
		}

		err = group.Wait()    // ожидаем завершения всех обработчиков сервисов
		conn.Close()          // закрываем соединение
		if ctx.Err() != nil { // отслеживаем плановую остановку сервиса
			return nil
		}
		// осуществляем повторное соединение и инициализацию
	}
}

// WorkAsync запускает асинхронное выполнение Work и ожидает завершения начального процесса инициализации,
// после чего продолжает работу обработчиков в фоновом режиме, а сам завершается. Возвращает ошибку, если при
// первой инициализации обработчиков или при установлении соединения произошла ошибка.
func WorkAsync(ctx context.Context, addr string, workers ...Worker) error {
	var (
		stop = make(chan struct{}) // канал для отслеживания инициализации
		err  error                 // отслеживаем ошибку первой инициализации сервисов при запуске
	)

	go func() {
		defer close(stop) // по окончании или ошибке тоже закрываем, если не дошло до нашего сервиса
		// добавляем свой обработчик, чтобы отследить окончание процесса инициализации
		err = Work(ctx, addr, append(workers, func(*amqp091.Channel) error {
			close(stop) // закрываем канал при инициализации сервиса
			return nil  // завершаем работу сервиса без ошибки
		})...) // запускаем параллельную обработку
	}()

	<-stop // ожидаем завершения инициализации
	return err
}
